[Constructor(),Constructor(MediaStream stream),Constructor(sequence<MediaStreamTrack> tracks)]
[Exposed=Window] interface MediaStream : EventTarget {
readonly attribute DOMString id;
sequence<MediaStreamTrack> getAudioTracks();
sequence<MediaStreamTrack> getVideoTracks();
sequence<MediaStreamTrack> getTracks();
MediaStreamTrack? getTrackById(DOMString trackId);
void addTrack(MediaStreamTrack track);
void removeTrack(MediaStreamTrack track);
MediaStream clone();
readonly attribute boolean active;
attribute EventHandler onactive;
attribute EventHandler oninactive;
attribute EventHandler onaddtrack;
attribute EventHandler onremovetrack;
};
[Exposed=Window] interface MediaStreamTrack : EventTarget {
readonly attribute DOMString kind;
readonly attribute DOMString id;
readonly attribute DOMString label;
attribute boolean enabled;
readonly attribute boolean muted;
attribute EventHandler onmute;
attribute EventHandler onunmute;
readonly attribute boolean _readonly;
readonly attribute boolean remote;
readonly attribute MediaStreamTrackState readyState;
attribute EventHandler onended;
MediaStreamTrack clone();
void stop();
MediaTrackCapabilities getCapabilities();
MediaTrackConstraints getConstraints();
MediaTrackSettings getSettings();
Promise<void> applyConstraints();
attribute EventHandler onoverconstrained;
};
enum MediaStreamTrackState {
"live", "ended"
};
enum SourceTypeEnum {
"camera", "microphone"
};
dictionary MediaTrackSupportedConstraints {
boolean width;
boolean height;
boolean aspectRatio;
boolean frameRate;
boolean facingMode;
boolean volume;
boolean sampleRate;
boolean sampleSize;
boolean echoCancellation;
boolean latency;
boolean deviceId;
boolean groupId;
};
dictionary MediaTrackCapabilities {
(long or LongRange) width;
(long or LongRange) height;
(double or DoubleRange) aspectRatio;
(double or DoubleRange) frameRate;
DOMString facingMode;
(double or DoubleRange) volume;
(long or LongRange) sampleRate;
(long or LongRange) sampleSize;
sequence<boolean> echoCancellation;
(double or DoubleRange) latency;
DOMString deviceId;
DOMString groupId;
};
dictionary MediaTrackConstraints : MediaTrackConstraintSet {
sequence<MediaTrackConstraintSet> advanced;
};
dictionary MediaTrackConstraintSet {
ConstrainLong width;
ConstrainLong height;
ConstrainDouble aspectRatio;
ConstrainDouble frameRate;
ConstrainDOMString facingMode;
ConstrainDouble volume;
ConstrainLong sampleRate;
ConstrainLong sampleSize;
ConstrainBoolean echoCancellation;
ConstrainDouble latency;
ConstrainDOMString deviceId;
ConstrainDOMString groupId;
};
dictionary MediaTrackSettings {
long width;
long height;
double aspectRatio;
double frameRate;
DOMString facingMode;
double volume;
long sampleRate;
long sampleSize;
boolean echoCancellation;
double latency;
DOMString deviceId;
DOMString groupId;
};
[Constructor(DOMString type, MediaStreamTrackEventInit eventInitDict)]
[Exposed=Window] interface MediaStreamTrackEvent : Event {
readonly attribute MediaStreamTrack track;
};
dictionary MediaStreamTrackEventInit : EventInit {
};
[Exposed=Window, NoInterfaceObject] interface MediaStreamError {
readonly attribute DOMString name;
readonly attribute DOMString? message;
readonly attribute DOMString? constraintName;
};
[Constructor(DOMString type, MediaStreamErrorEventInit eventInitDict)]
[Exposed=Window] interface MediaStreamErrorEvent : Event {
readonly attribute MediaStreamError? error;
};
dictionary MediaStreamErrorEventInit : EventInit {
MediaStreamError? error = null;
};
[Exposed=Window, NoInterfaceObject] interface NavigatorUserMedia {
readonly attribute MediaDevices mediaDevices;
};
[Exposed=Window] interface MediaDevices : EventTarget {
attribute EventHandler ondevicechange;
Promise<sequence<MediaDeviceInfo>> enumerateDevices ();
};
[Exposed=Window] interface MediaDeviceInfo {
readonly attribute DOMString deviceId;
readonly attribute MediaDeviceKind kind;
readonly attribute DOMString label;
readonly attribute DOMString groupId;
};
enum MediaDeviceKind {
"audioinput", "audiooutput", "videoinput"
};
partial interface NavigatorUserMedia {
void getUserMedia(MediaStreamConstraints constraints, NavigatorUserMediaSuccessCallback successCallback, NavigatorUserMediaErrorCallback errorCallback);
};
partial interface MediaDevices {
MediaTrackSupportedConstraints getSupportedConstraints();
Promise<MediaStream> getUserMedia( MediaStreamConstraints constraints);
};
dictionary MediaStreamConstraints {
(boolean or MediaTrackConstraints) video = false;
(boolean or MediaTrackConstraints) audio = false;
};
callback NavigatorUserMediaSuccessCallback = void
(MediaStream stream)
;
callback NavigatorUserMediaErrorCallback = void
(MediaStreamError error)
;
[NoInterfaceObject] interface ConstrainablePattern {
Capabilities getCapabilities();
Constraints getConstraints();
Settings getSettings();
Promise<void> applyConstraints();
attribute EventHandler onoverconstrained;
};
dictionary DoubleRange {
double max;
double min;
};
dictionary ConstrainDoubleRange : DoubleRange {
double exact;
double ideal;
};
dictionary LongRange {
long max;
long min;
};
dictionary ConstrainLongRange : LongRange {
long exact;
long ideal;
};
dictionary ConstrainBooleanParameters {
boolean exact;
boolean ideal;
};
dictionary ConstrainDOMStringParameters {
(DOMString or sequence<DOMString>) exact;
(DOMString or sequence<DOMString>) ideal;
};
typedef (long or ConstrainLongRange) ConstrainLong
;
typedef (double or ConstrainDoubleRange) ConstrainDouble
;
typedef (boolean or ConstrainBooleanParameters) ConstrainBoolean
;
typedef (DOMString or sequence<DOMString> or ConstrainDOMStringParameters) ConstrainDOMString
;
dictionary ConstraintSet {
};
dictionary Constraints : ConstraintSet {
sequence<ConstraintSet> advanced;
};
enum VideoFacingModeEnum {
"user", "environment", "left", "right"
};
